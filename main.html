<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Melodious Grove Blog</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <label for="title">Melodious Grove - Blog Post</label>
  <div id="blog-section">
    <h2>Overview</h2>

    <a href="https://elvinawibisono.github.io/melodious_grove/intro_story/intro.html">Melodious Grove</a>

    <p>Click the link above to play the game!</p>

    <p>
      This game follows a young girl, Ari, as she journeys into the Melodious Grove, a mysterious forest, to complete a series of musical tasks in order to obtain ingredients to make a magic potion to save her grandma.
      Melodious Grove is developed using WebAudio and the 3 different musical tasks, presented as mini games, are meant to showcase the different concepts and techniques we learned in COMS 3430: Computational Sound class.
    </p>

    
    <h2>Intro</h2>

    <p>
      The game opens with an introductory story. The user is introduced to Ari and is told of her main goal of the game.
      We were inspired by old games we grew up to, like Pokemon, and to match that aesthetic, we have a visual of Ari as a pixellated game character
      and changed the font to match. The story is told with a typewriter effect and the user can press 'ENTER' to get the next line 
      of texts, just like in Pokemon. On the 
    </p>

    <h2>Minigame 1 - Echo Direction</h2>

    <h2>Minigame 2 - Frequency Matching</h2>

    <h2>Minigame 3 - Memory Pattern</h2>
    <h3>Goal</h3>
    <p>For this game, we wanted to use the ASMR enveloping feature, which is something we wanted to improve from our past homeworks that had clicking. 
      Intiially, we were ambitious as we wanted to change the oscillators and the waveform, and have other instruments other than a piano. This would have
      been similar implementation as the benchmark we already have for the piano sequence; however, it would have been significantly more front-end, which 
      seemed out of the scope of this particular assignment. </p>
      <p>Since we ultimately wanted to bridge the knowledge we learned in computational sound with human-computer interaction knowledge, we decided to make a game
        where the user must perform a memorization task. This bridges what we learned about generating smooth sounds with WebAudio, as well as controlling gain values,
        oscillartors, and managing multiple notes at once. There was also a generative aspect of this assignment, which took inspiration from live coding.
        This was that the pattern that is generated from the computer is random. Given that the user generated notes and the computer generated notes are happening
        simultaneously, we not only have to manage multiple oscillators and gain nodes, but also two completely different audio contexts. This showed challenging at times. </p>
      
    <h3>Challenges</h3>
    <p>Challenges we faced on minigame had a lot to do with timing. Since we are generaring a sequence of notes, we had to figure out how to time the visuals with the sound correctly,
      and then since there were a total of 24 different notes, we needed to keep track of all of them simultaneously. We had to debug to make sure every node was connected
      correctly. Another challenge we had for this game was the front-end. A note on hard-coding: the position of each of the dots are computed, not hard coded; however,
      in the html file, we needed to create distinct dots for every single note. This is because we initally planned for the user to be able to play multiple notes at one time.
      This did not get added to our final game, as we decided that our game exhibits computational sound concepts enough, and we did not need to add extraneous levels. 
    </p>

    <h3>Choices</h3>
    <ul>
      <li>Pattern matching: We decided to do pattern matching and not pitch recognition, because it would be easier for the general audience. Without training
        in knowing pitches, there is no other way to have predicted.</li>
      <li>Sine wave: This sounded most like a common grand piano.</li>
      <li>7 notes: 7 is a good number for notes to be generated. </li>
      <li>Increments of 5, 12, 24. 5 is a good start, as 5 different notes will account for around half of the "bottom" level. 12, will account for all of the 
        "bottom" keys, and then 24 will range the entire keyboard. </li>
      <li>Instrument: Piano is the easiest to visualize, as the piano keyboard has direct correlation with the computer keyboard. Since this is the most intutive, it was best fit for a game  
        targeted to the general public.</li>
    </ul>


    <h2>Outro</h2>

</div>
</body>


</html>